        -:    0:Source:/home/spinoza/github/alpha/algebraic_reducers/tests/test_utility_coverage.cpp
        -:    1:#include <gtest/gtest.h>
        -:    2:#include <vector>
        -:    3:#include <cmath>
        -:    4:#include <limits>
        -:    5:#include "kbn_sum.hpp"
        -:    6:#include "welford_accumulator.hpp"
        -:    7:
        -:    8:using namespace algebraic_accumulator;
        -:    9:using namespace algebraic_accumulators;
        -:   10:
        -:   11:class UtilityCoverageTest : public ::testing::Test {
        -:   12:protected:
       11:   13:    void SetUp() override {}
       11:   14:    void TearDown() override {}
        -:   15:};
        -:   16:
        -:   17:// Test the abs function for kbn_sum
        4:   18:TEST_F(UtilityCoverageTest, KBNSumAbsFunction) {
        1:   19:    kbn_sum<double> positive(5.5);
        1:   20:    positive.c = 0.5; // Add some correction term
        -:   21:    
        1:   22:    auto abs_result = abs(positive);
       1*:   23:    EXPECT_EQ(abs_result.s, 5.5);
       1*:   24:    EXPECT_EQ(abs_result.c, 0.5);
        -:   25:    
        -:   26:    // Test with negative values
        1:   27:    kbn_sum<double> negative(-3.2);
        1:   28:    negative.c = -0.8; // Negative correction
        -:   29:    
        1:   30:    auto abs_negative = abs(negative);
       1*:   31:    EXPECT_EQ(abs_negative.s, 3.2);  // std::abs(-3.2) = 3.2
       1*:   32:    EXPECT_EQ(abs_negative.c, 0.8);  // std::abs(-0.8) = 0.8
        -:   33:    
        -:   34:    // Test with mixed signs
        1:   35:    kbn_sum<double> mixed(-2.0);
        1:   36:    mixed.c = 1.5; // Positive correction with negative sum
        -:   37:    
        1:   38:    auto abs_mixed = abs(mixed);
       1*:   39:    EXPECT_EQ(abs_mixed.s, 2.0);
       1*:   40:    EXPECT_EQ(abs_mixed.c, 1.5);
        1:   41:}
------------------
_ZN42UtilityCoverageTest_KBNSumAbsFunction_TestC2Ev:
        1:   18:TEST_F(UtilityCoverageTest, KBNSumAbsFunction) {
------------------
_ZN42UtilityCoverageTest_KBNSumAbsFunction_TestD0Ev:
        1:   18:TEST_F(UtilityCoverageTest, KBNSumAbsFunction) {
------------------
_ZN42UtilityCoverageTest_KBNSumAbsFunction_TestD2Ev:
        1:   18:TEST_F(UtilityCoverageTest, KBNSumAbsFunction) {
------------------
_ZN42UtilityCoverageTest_KBNSumAbsFunction_Test8TestBodyEv:
        1:   18:TEST_F(UtilityCoverageTest, KBNSumAbsFunction) {
        1:   19:    kbn_sum<double> positive(5.5);
        1:   20:    positive.c = 0.5; // Add some correction term
        -:   21:    
        1:   22:    auto abs_result = abs(positive);
       1*:   23:    EXPECT_EQ(abs_result.s, 5.5);
       1*:   24:    EXPECT_EQ(abs_result.c, 0.5);
        -:   25:    
        -:   26:    // Test with negative values
        1:   27:    kbn_sum<double> negative(-3.2);
        1:   28:    negative.c = -0.8; // Negative correction
        -:   29:    
        1:   30:    auto abs_negative = abs(negative);
       1*:   31:    EXPECT_EQ(abs_negative.s, 3.2);  // std::abs(-3.2) = 3.2
       1*:   32:    EXPECT_EQ(abs_negative.c, 0.8);  // std::abs(-0.8) = 0.8
        -:   33:    
        -:   34:    // Test with mixed signs
        1:   35:    kbn_sum<double> mixed(-2.0);
        1:   36:    mixed.c = 1.5; // Positive correction with negative sum
        -:   37:    
        1:   38:    auto abs_mixed = abs(mixed);
       1*:   39:    EXPECT_EQ(abs_mixed.s, 2.0);
       1*:   40:    EXPECT_EQ(abs_mixed.c, 1.5);
        1:   41:}
------------------
        -:   42:
        -:   43:// Test float specialization branch coverage for KBN sum
        4:   44:TEST_F(UtilityCoverageTest, KBNSumFloatBranchCoverage) {
        1:   45:    kbn_sum<float> sum(1.0f);
        -:   46:    
        -:   47:    // Force the condition where abs(x) < abs(s) for float
        1:   48:    sum.s = 10.0f;
        1:   49:    sum.c = 0.0f;
        1:   50:    sum += 1.0f; // abs(1.0f) < abs(10.0f), so should hit first branch
        -:   51:    
       1*:   52:    EXPECT_GT(static_cast<float>(sum), 10.5f);
        -:   53:    
        -:   54:    // Test the else branch for float: abs(x) >= abs(s)
        1:   55:    kbn_sum<float> sum2(1.0f);
        1:   56:    sum2 += 10.0f; // abs(10.0f) >= abs(1.0f), should hit else branch
        -:   57:    
       1*:   58:    EXPECT_EQ(static_cast<float>(sum2), 11.0f);
        1:   59:}
------------------
_ZN50UtilityCoverageTest_KBNSumFloatBranchCoverage_TestC2Ev:
        1:   44:TEST_F(UtilityCoverageTest, KBNSumFloatBranchCoverage) {
------------------
_ZN50UtilityCoverageTest_KBNSumFloatBranchCoverage_TestD0Ev:
        1:   44:TEST_F(UtilityCoverageTest, KBNSumFloatBranchCoverage) {
------------------
_ZN50UtilityCoverageTest_KBNSumFloatBranchCoverage_TestD2Ev:
        1:   44:TEST_F(UtilityCoverageTest, KBNSumFloatBranchCoverage) {
------------------
_ZN50UtilityCoverageTest_KBNSumFloatBranchCoverage_Test8TestBodyEv:
        1:   44:TEST_F(UtilityCoverageTest, KBNSumFloatBranchCoverage) {
        1:   45:    kbn_sum<float> sum(1.0f);
        -:   46:    
        -:   47:    // Force the condition where abs(x) < abs(s) for float
        1:   48:    sum.s = 10.0f;
        1:   49:    sum.c = 0.0f;
        1:   50:    sum += 1.0f; // abs(1.0f) < abs(10.0f), so should hit first branch
        -:   51:    
       1*:   52:    EXPECT_GT(static_cast<float>(sum), 10.5f);
        -:   53:    
        -:   54:    // Test the else branch for float: abs(x) >= abs(s)
        1:   55:    kbn_sum<float> sum2(1.0f);
        1:   56:    sum2 += 10.0f; // abs(10.0f) >= abs(1.0f), should hit else branch
        -:   57:    
       1*:   58:    EXPECT_EQ(static_cast<float>(sum2), 11.0f);
        1:   59:}
------------------
        -:   60:
        -:   61:// Test uncovered Welford accumulator methods
        4:   62:TEST_F(UtilityCoverageTest, WelfordUtilityFunctions) {
        1:   63:    welford_accumulator<kbn_sum<double>> acc;
        -:   64:    
        -:   65:    // Add some data points
        2:   66:    std::vector<double> data = {1.0, 2.0, 3.0, 4.0, 5.0};
        6:   67:    for (double val : data) {
        5:   68:        acc += val;
        -:   69:    }
        -:   70:    
        -:   71:    // Test variance method directly
        1:   72:    double var = acc.variance();
       1*:   73:    EXPECT_DOUBLE_EQ(var, 2.0);
        -:   74:    
        -:   75:    // Test sample_variance method directly  
        1:   76:    double sample_var = acc.sample_variance();
       1*:   77:    EXPECT_DOUBLE_EQ(sample_var, 2.5);
        -:   78:    
        -:   79:    // Test sum method directly
        1:   80:    double total = acc.sum();
       1*:   81:    EXPECT_DOUBLE_EQ(total, 15.0);
        -:   82:    
        -:   83:    // Test utility functions (global functions)
       1*:   84:    EXPECT_DOUBLE_EQ(mean(acc), 3.0);
       1*:   85:    EXPECT_DOUBLE_EQ(variance(acc), 2.0);
       1*:   86:    EXPECT_DOUBLE_EQ(sample_variance(acc), 2.5);
       1*:   87:    EXPECT_EQ(size(acc), 5u);
       1*:   88:    EXPECT_DOUBLE_EQ(sum(acc), 15.0);
        -:   89:    
        -:   90:    // Test conversion operator
        1:   91:    double converted_value = static_cast<double>(acc);
       1*:   92:    EXPECT_DOUBLE_EQ(converted_value, 15.0);
        1:   93:}
------------------
_ZN48UtilityCoverageTest_WelfordUtilityFunctions_TestC2Ev:
        1:   62:TEST_F(UtilityCoverageTest, WelfordUtilityFunctions) {
------------------
_ZN48UtilityCoverageTest_WelfordUtilityFunctions_TestD0Ev:
        1:   62:TEST_F(UtilityCoverageTest, WelfordUtilityFunctions) {
------------------
_ZN48UtilityCoverageTest_WelfordUtilityFunctions_TestD2Ev:
        1:   62:TEST_F(UtilityCoverageTest, WelfordUtilityFunctions) {
------------------
_ZN48UtilityCoverageTest_WelfordUtilityFunctions_Test8TestBodyEv:
        1:   62:TEST_F(UtilityCoverageTest, WelfordUtilityFunctions) {
        1:   63:    welford_accumulator<kbn_sum<double>> acc;
        -:   64:    
        -:   65:    // Add some data points
        2:   66:    std::vector<double> data = {1.0, 2.0, 3.0, 4.0, 5.0};
        6:   67:    for (double val : data) {
        5:   68:        acc += val;
        -:   69:    }
        -:   70:    
        -:   71:    // Test variance method directly
        1:   72:    double var = acc.variance();
       1*:   73:    EXPECT_DOUBLE_EQ(var, 2.0);
        -:   74:    
        -:   75:    // Test sample_variance method directly  
        1:   76:    double sample_var = acc.sample_variance();
       1*:   77:    EXPECT_DOUBLE_EQ(sample_var, 2.5);
        -:   78:    
        -:   79:    // Test sum method directly
        1:   80:    double total = acc.sum();
       1*:   81:    EXPECT_DOUBLE_EQ(total, 15.0);
        -:   82:    
        -:   83:    // Test utility functions (global functions)
       1*:   84:    EXPECT_DOUBLE_EQ(mean(acc), 3.0);
       1*:   85:    EXPECT_DOUBLE_EQ(variance(acc), 2.0);
       1*:   86:    EXPECT_DOUBLE_EQ(sample_variance(acc), 2.5);
       1*:   87:    EXPECT_EQ(size(acc), 5u);
       1*:   88:    EXPECT_DOUBLE_EQ(sum(acc), 15.0);
        -:   89:    
        -:   90:    // Test conversion operator
        1:   91:    double converted_value = static_cast<double>(acc);
       1*:   92:    EXPECT_DOUBLE_EQ(converted_value, 15.0);
        1:   93:}
------------------
        -:   94:
        -:   95:// Test value constructor for Welford accumulator
        4:   96:TEST_F(UtilityCoverageTest, WelfordValueConstructor) {
        1:   97:    welford_accumulator<kbn_sum<double>> acc(10.0);
        -:   98:    
       1*:   99:    EXPECT_EQ(acc.size(), 1u);
       1*:  100:    EXPECT_DOUBLE_EQ(acc.mean(), 10.0);
       1*:  101:    EXPECT_DOUBLE_EQ(acc.sum(), 10.0);
        -:  102:    
        -:  103:    // Add another value to test it works properly
        1:  104:    acc += 20.0;
       1*:  105:    EXPECT_EQ(acc.size(), 2u);
       1*:  106:    EXPECT_DOUBLE_EQ(acc.mean(), 15.0);
       1*:  107:    EXPECT_DOUBLE_EQ(acc.sum(), 30.0);
        1:  108:}
------------------
_ZN48UtilityCoverageTest_WelfordValueConstructor_TestC2Ev:
        1:   96:TEST_F(UtilityCoverageTest, WelfordValueConstructor) {
------------------
_ZN48UtilityCoverageTest_WelfordValueConstructor_TestD0Ev:
        1:   96:TEST_F(UtilityCoverageTest, WelfordValueConstructor) {
------------------
_ZN48UtilityCoverageTest_WelfordValueConstructor_TestD2Ev:
        1:   96:TEST_F(UtilityCoverageTest, WelfordValueConstructor) {
------------------
_ZN48UtilityCoverageTest_WelfordValueConstructor_Test8TestBodyEv:
        1:   96:TEST_F(UtilityCoverageTest, WelfordValueConstructor) {
        1:   97:    welford_accumulator<kbn_sum<double>> acc(10.0);
        -:   98:    
       1*:   99:    EXPECT_EQ(acc.size(), 1u);
       1*:  100:    EXPECT_DOUBLE_EQ(acc.mean(), 10.0);
       1*:  101:    EXPECT_DOUBLE_EQ(acc.sum(), 10.0);
        -:  102:    
        -:  103:    // Add another value to test it works properly
        1:  104:    acc += 20.0;
       1*:  105:    EXPECT_EQ(acc.size(), 2u);
       1*:  106:    EXPECT_DOUBLE_EQ(acc.mean(), 15.0);
       1*:  107:    EXPECT_DOUBLE_EQ(acc.sum(), 30.0);
        1:  108:}
------------------
        -:  109:
        -:  110:// Test KBN sum eval method
        4:  111:TEST_F(UtilityCoverageTest, KBNSumEvalMethod) {
        1:  112:    kbn_sum<double> sum(5.0);
        1:  113:    sum.c = 2.5;
        -:  114:    
       1*:  115:    EXPECT_DOUBLE_EQ(sum.eval(), 7.5);
       1*:  116:    EXPECT_DOUBLE_EQ(static_cast<double>(sum), sum.eval());
        1:  117:}
------------------
_ZN41UtilityCoverageTest_KBNSumEvalMethod_TestC2Ev:
        1:  111:TEST_F(UtilityCoverageTest, KBNSumEvalMethod) {
------------------
_ZN41UtilityCoverageTest_KBNSumEvalMethod_TestD0Ev:
        1:  111:TEST_F(UtilityCoverageTest, KBNSumEvalMethod) {
------------------
_ZN41UtilityCoverageTest_KBNSumEvalMethod_TestD2Ev:
        1:  111:TEST_F(UtilityCoverageTest, KBNSumEvalMethod) {
------------------
_ZN41UtilityCoverageTest_KBNSumEvalMethod_Test8TestBodyEv:
        1:  111:TEST_F(UtilityCoverageTest, KBNSumEvalMethod) {
        1:  112:    kbn_sum<double> sum(5.0);
        1:  113:    sum.c = 2.5;
        -:  114:    
       1*:  115:    EXPECT_DOUBLE_EQ(sum.eval(), 7.5);
       1*:  116:    EXPECT_DOUBLE_EQ(static_cast<double>(sum), sum.eval());
        1:  117:}
------------------
        -:  118:
        -:  119:// Test KBN sum comparison with scalar
        4:  120:TEST_F(UtilityCoverageTest, KBNSumScalarComparison) {
        1:  121:    kbn_sum<double> sum(5.0);
        1:  122:    sum.c = 0.5;
        -:  123:    
       1*:  124:    EXPECT_TRUE(sum < 6.0);
       1*:  125:    EXPECT_FALSE(sum < 5.0);
       1*:  126:    EXPECT_FALSE(sum < 5.5);
        1:  127:}
------------------
_ZN47UtilityCoverageTest_KBNSumScalarComparison_TestC2Ev:
        1:  120:TEST_F(UtilityCoverageTest, KBNSumScalarComparison) {
------------------
_ZN47UtilityCoverageTest_KBNSumScalarComparison_TestD0Ev:
        1:  120:TEST_F(UtilityCoverageTest, KBNSumScalarComparison) {
------------------
_ZN47UtilityCoverageTest_KBNSumScalarComparison_TestD2Ev:
        1:  120:TEST_F(UtilityCoverageTest, KBNSumScalarComparison) {
------------------
_ZN47UtilityCoverageTest_KBNSumScalarComparison_Test8TestBodyEv:
        1:  120:TEST_F(UtilityCoverageTest, KBNSumScalarComparison) {
        1:  121:    kbn_sum<double> sum(5.0);
        1:  122:    sum.c = 0.5;
        -:  123:    
       1*:  124:    EXPECT_TRUE(sum < 6.0);
       1*:  125:    EXPECT_FALSE(sum < 5.0);
       1*:  126:    EXPECT_FALSE(sum < 5.5);
        1:  127:}
------------------
        -:  128:
        -:  129:// Test KBN sum assignment operator
        4:  130:TEST_F(UtilityCoverageTest, KBNSumValueAssignment) {
        1:  131:    kbn_sum<double> sum(10.0);
        1:  132:    sum.c = 5.0; // This should be preserved by assignment
        -:  133:    
        1:  134:    sum = 3.0;
       1*:  135:    EXPECT_DOUBLE_EQ(sum.s, 3.0);
       1*:  136:    EXPECT_DOUBLE_EQ(static_cast<double>(sum), 8.0); // s=3.0 + c=5.0 = 8.0 (c is preserved)
        1:  137:}
------------------
_ZN46UtilityCoverageTest_KBNSumValueAssignment_TestC2Ev:
        1:  130:TEST_F(UtilityCoverageTest, KBNSumValueAssignment) {
------------------
_ZN46UtilityCoverageTest_KBNSumValueAssignment_TestD0Ev:
        1:  130:TEST_F(UtilityCoverageTest, KBNSumValueAssignment) {
------------------
_ZN46UtilityCoverageTest_KBNSumValueAssignment_TestD2Ev:
        1:  130:TEST_F(UtilityCoverageTest, KBNSumValueAssignment) {
------------------
_ZN46UtilityCoverageTest_KBNSumValueAssignment_Test8TestBodyEv:
        1:  130:TEST_F(UtilityCoverageTest, KBNSumValueAssignment) {
        1:  131:    kbn_sum<double> sum(10.0);
        1:  132:    sum.c = 5.0; // This should be preserved by assignment
        -:  133:    
        1:  134:    sum = 3.0;
       1*:  135:    EXPECT_DOUBLE_EQ(sum.s, 3.0);
       1*:  136:    EXPECT_DOUBLE_EQ(static_cast<double>(sum), 8.0); // s=3.0 + c=5.0 = 8.0 (c is preserved)
        1:  137:}
------------------
        -:  138:
        -:  139:// Test edge cases with very small and large numbers
        4:  140:TEST_F(UtilityCoverageTest, ExtremePrecisionCases) {
        1:  141:    kbn_sum<double> sum;
        -:  142:    
        -:  143:    // Add very large number followed by very small ones
        1:  144:    sum += 1e16;
        1:  145:    sum += 1.0;
        1:  146:    sum += 1.0;
        1:  147:    sum += -1e16;
        -:  148:    
        -:  149:    // KBN sum should preserve the 2.0 better than naive summation
        1:  150:    double result = static_cast<double>(sum);
       1*:  151:    EXPECT_NEAR(result, 2.0, 1e-10);
       1*:  152:    EXPECT_GT(result, 1.9); // Should be better than total loss of precision
        1:  153:}
------------------
_ZN46UtilityCoverageTest_ExtremePrecisionCases_TestC2Ev:
        1:  140:TEST_F(UtilityCoverageTest, ExtremePrecisionCases) {
------------------
_ZN46UtilityCoverageTest_ExtremePrecisionCases_TestD0Ev:
        1:  140:TEST_F(UtilityCoverageTest, ExtremePrecisionCases) {
------------------
_ZN46UtilityCoverageTest_ExtremePrecisionCases_TestD2Ev:
        1:  140:TEST_F(UtilityCoverageTest, ExtremePrecisionCases) {
------------------
_ZN46UtilityCoverageTest_ExtremePrecisionCases_Test8TestBodyEv:
        1:  140:TEST_F(UtilityCoverageTest, ExtremePrecisionCases) {
        1:  141:    kbn_sum<double> sum;
        -:  142:    
        -:  143:    // Add very large number followed by very small ones
        1:  144:    sum += 1e16;
        1:  145:    sum += 1.0;
        1:  146:    sum += 1.0;
        1:  147:    sum += -1e16;
        -:  148:    
        -:  149:    // KBN sum should preserve the 2.0 better than naive summation
        1:  150:    double result = static_cast<double>(sum);
       1*:  151:    EXPECT_NEAR(result, 2.0, 1e-10);
       1*:  152:    EXPECT_GT(result, 1.9); // Should be better than total loss of precision
        1:  153:}
------------------
        -:  154:
        -:  155:// Test Welford accumulator with edge cases
        4:  156:TEST_F(UtilityCoverageTest, WelfordEdgeCases) {
        1:  157:    welford_accumulator<kbn_sum<double>> acc;
        -:  158:    
        -:  159:    // Single value case
        1:  160:    acc += 42.0;
       1*:  161:    EXPECT_DOUBLE_EQ(acc.mean(), 42.0);
       1*:  162:    EXPECT_DOUBLE_EQ(acc.variance(), 0.0);
        -:  163:    
        -:  164:    // Two identical values
        1:  165:    acc += 42.0;
       1*:  166:    EXPECT_DOUBLE_EQ(acc.mean(), 42.0);
       1*:  167:    EXPECT_DOUBLE_EQ(acc.variance(), 0.0);
       1*:  168:    EXPECT_DOUBLE_EQ(acc.sample_variance(), 0.0);
        1:  169:}
------------------
_ZN41UtilityCoverageTest_WelfordEdgeCases_TestC2Ev:
        1:  156:TEST_F(UtilityCoverageTest, WelfordEdgeCases) {
------------------
_ZN41UtilityCoverageTest_WelfordEdgeCases_TestD0Ev:
        1:  156:TEST_F(UtilityCoverageTest, WelfordEdgeCases) {
------------------
_ZN41UtilityCoverageTest_WelfordEdgeCases_TestD2Ev:
        1:  156:TEST_F(UtilityCoverageTest, WelfordEdgeCases) {
------------------
_ZN41UtilityCoverageTest_WelfordEdgeCases_Test8TestBodyEv:
        1:  156:TEST_F(UtilityCoverageTest, WelfordEdgeCases) {
        1:  157:    welford_accumulator<kbn_sum<double>> acc;
        -:  158:    
        -:  159:    // Single value case
        1:  160:    acc += 42.0;
       1*:  161:    EXPECT_DOUBLE_EQ(acc.mean(), 42.0);
       1*:  162:    EXPECT_DOUBLE_EQ(acc.variance(), 0.0);
        -:  163:    
        -:  164:    // Two identical values
        1:  165:    acc += 42.0;
       1*:  166:    EXPECT_DOUBLE_EQ(acc.mean(), 42.0);
       1*:  167:    EXPECT_DOUBLE_EQ(acc.variance(), 0.0);
       1*:  168:    EXPECT_DOUBLE_EQ(acc.sample_variance(), 0.0);
        1:  169:}
------------------
        -:  170:
        -:  171:// Test using KBN welford type alias
        4:  172:TEST_F(UtilityCoverageTest, KBNWelfordTypeAlias) {
        1:  173:    kbn_welford_accumulate<double> acc;
        -:  174:    
        1:  175:    acc += 1.0;
        1:  176:    acc += 2.0;
        1:  177:    acc += 3.0;
        -:  178:    
       1*:  179:    EXPECT_EQ(acc.size(), 3u);
       1*:  180:    EXPECT_DOUBLE_EQ(acc.mean(), 2.0);
       1*:  181:    EXPECT_DOUBLE_EQ(acc.sum(), 6.0);
        1:  182:}
------------------
_ZN44UtilityCoverageTest_KBNWelfordTypeAlias_TestC2Ev:
        1:  172:TEST_F(UtilityCoverageTest, KBNWelfordTypeAlias) {
------------------
_ZN44UtilityCoverageTest_KBNWelfordTypeAlias_TestD0Ev:
        1:  172:TEST_F(UtilityCoverageTest, KBNWelfordTypeAlias) {
------------------
_ZN44UtilityCoverageTest_KBNWelfordTypeAlias_TestD2Ev:
        1:  172:TEST_F(UtilityCoverageTest, KBNWelfordTypeAlias) {
------------------
_ZN44UtilityCoverageTest_KBNWelfordTypeAlias_Test8TestBodyEv:
        1:  172:TEST_F(UtilityCoverageTest, KBNWelfordTypeAlias) {
        1:  173:    kbn_welford_accumulate<double> acc;
        -:  174:    
        1:  175:    acc += 1.0;
        1:  176:    acc += 2.0;
        1:  177:    acc += 3.0;
        -:  178:    
       1*:  179:    EXPECT_EQ(acc.size(), 3u);
       1*:  180:    EXPECT_DOUBLE_EQ(acc.mean(), 2.0);
       1*:  181:    EXPECT_DOUBLE_EQ(acc.sum(), 6.0);
        1:  182:}
------------------
        -:  183:
        -:  184:// Test zero and negative operations more thoroughly
        4:  185:TEST_F(UtilityCoverageTest, ZeroAndNegativeOperations) {
        1:  186:    kbn_sum<double> sum;
        -:  187:    
        -:  188:    // Test operations with zero
        1:  189:    sum += 0.0;
       1*:  190:    EXPECT_DOUBLE_EQ(static_cast<double>(sum), 0.0);
        -:  191:    
        1:  192:    sum += -0.0;
       1*:  193:    EXPECT_DOUBLE_EQ(static_cast<double>(sum), 0.0);
        -:  194:    
        -:  195:    // Test negative cancellation
        1:  196:    sum = 5.0;
        1:  197:    sum += -5.0;
       1*:  198:    EXPECT_DOUBLE_EQ(static_cast<double>(sum), 0.0);
        1:  199:}
------------------
_ZN50UtilityCoverageTest_ZeroAndNegativeOperations_TestC2Ev:
        1:  185:TEST_F(UtilityCoverageTest, ZeroAndNegativeOperations) {
------------------
_ZN50UtilityCoverageTest_ZeroAndNegativeOperations_TestD0Ev:
        1:  185:TEST_F(UtilityCoverageTest, ZeroAndNegativeOperations) {
------------------
_ZN50UtilityCoverageTest_ZeroAndNegativeOperations_TestD2Ev:
        1:  185:TEST_F(UtilityCoverageTest, ZeroAndNegativeOperations) {
------------------
_ZN50UtilityCoverageTest_ZeroAndNegativeOperations_Test8TestBodyEv:
        1:  185:TEST_F(UtilityCoverageTest, ZeroAndNegativeOperations) {
        1:  186:    kbn_sum<double> sum;
        -:  187:    
        -:  188:    // Test operations with zero
        1:  189:    sum += 0.0;
       1*:  190:    EXPECT_DOUBLE_EQ(static_cast<double>(sum), 0.0);
        -:  191:    
        1:  192:    sum += -0.0;
       1*:  193:    EXPECT_DOUBLE_EQ(static_cast<double>(sum), 0.0);
        -:  194:    
        -:  195:    // Test negative cancellation
        1:  196:    sum = 5.0;
        1:  197:    sum += -5.0;
       1*:  198:    EXPECT_DOUBLE_EQ(static_cast<double>(sum), 0.0);
        1:  199:}
------------------
