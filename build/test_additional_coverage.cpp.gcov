        -:    0:Source:/home/spinoza/github/alpha/algebraic_reducers/tests/test_additional_coverage.cpp
        -:    1:#include <gtest/gtest.h>
        -:    2:#include <vector>
        -:    3:#include <limits>
        -:    4:#include "kbn_sum.hpp"
        -:    5:#include "welford_accumulator.hpp"
        -:    6:
        -:    7:using namespace algebraic_accumulator;
        -:    8:using namespace algebraic_accumulators;
        -:    9:
        -:   10:class AdditionalCoverageTest : public ::testing::Test {
        -:   11:protected:
        4:   12:    void SetUp() override {}
        4:   13:    void TearDown() override {}
        -:   14:};
        -:   15:
        -:   16:// Test specific edge cases that might not be covered
        4:   17:TEST_F(AdditionalCoverageTest, KBNSumSpecialCases) {
        -:   18:    // Test the specific branches in the += operator
        1:   19:    kbn_sum<double> sum;
        -:   20:    
        -:   21:    // Case where abs(x) == abs(s) - should go to the else branch
        1:   22:    sum.s = 5.0;
        1:   23:    sum += -5.0;  // abs(-5.0) == abs(5.0), should use ((x - t) + s) calculation
       1*:   24:    EXPECT_EQ(static_cast<double>(sum), 0.0);
        -:   25:    
        -:   26:    // Test with very small correction terms
        1:   27:    kbn_sum<float> float_sum(1e20f);
        1:   28:    float_sum += 1.0f;
        1:   29:    float_sum += 1.0f;
        1:   30:    float_sum += -1e20f;
        -:   31:    
        -:   32:    // Should preserve some precision due to KBN algorithm
        1:   33:    float result = static_cast<float>(float_sum);
       1*:   34:    EXPECT_GE(result, 1.5f); // Better than naive summation
        1:   35:}
------------------
_ZN46AdditionalCoverageTest_KBNSumSpecialCases_TestC2Ev:
        1:   17:TEST_F(AdditionalCoverageTest, KBNSumSpecialCases) {
------------------
_ZN46AdditionalCoverageTest_KBNSumSpecialCases_TestD0Ev:
        1:   17:TEST_F(AdditionalCoverageTest, KBNSumSpecialCases) {
------------------
_ZN46AdditionalCoverageTest_KBNSumSpecialCases_TestD2Ev:
        1:   17:TEST_F(AdditionalCoverageTest, KBNSumSpecialCases) {
------------------
_ZN46AdditionalCoverageTest_KBNSumSpecialCases_Test8TestBodyEv:
        1:   17:TEST_F(AdditionalCoverageTest, KBNSumSpecialCases) {
        -:   18:    // Test the specific branches in the += operator
        1:   19:    kbn_sum<double> sum;
        -:   20:    
        -:   21:    // Case where abs(x) == abs(s) - should go to the else branch
        1:   22:    sum.s = 5.0;
        1:   23:    sum += -5.0;  // abs(-5.0) == abs(5.0), should use ((x - t) + s) calculation
       1*:   24:    EXPECT_EQ(static_cast<double>(sum), 0.0);
        -:   25:    
        -:   26:    // Test with very small correction terms
        1:   27:    kbn_sum<float> float_sum(1e20f);
        1:   28:    float_sum += 1.0f;
        1:   29:    float_sum += 1.0f;
        1:   30:    float_sum += -1e20f;
        -:   31:    
        -:   32:    // Should preserve some precision due to KBN algorithm
        1:   33:    float result = static_cast<float>(float_sum);
       1*:   34:    EXPECT_GE(result, 1.5f); // Better than naive summation
        1:   35:}
------------------
        -:   36:
        -:   37:// Test welford accumulator with extreme values
        4:   38:TEST_F(AdditionalCoverageTest, WelfordSpecialCases) {
        1:   39:    welford_accumulator<kbn_sum<double>> acc;
        -:   40:    
        -:   41:    // Test with infinity values (if supported)
        1:   42:    acc += std::numeric_limits<double>::max();
        1:   43:    acc += std::numeric_limits<double>::max();
        -:   44:    
       1*:   45:    EXPECT_TRUE(std::isfinite(acc.mean()) || std::isinf(acc.mean()));
       1*:   46:    EXPECT_EQ(acc.size(), 2u);
        -:   47:    
        -:   48:    // Test move semantics path explicitly
        1:   49:    welford_accumulator<kbn_sum<double>> acc2;
        1:   50:    double temp = 5.0;
        1:   51:    acc2 += std::move(temp); // This triggers the move in delta2 calculation
       1*:   52:    EXPECT_EQ(acc2.mean(), 5.0);
        1:   53:}
------------------
_ZN47AdditionalCoverageTest_WelfordSpecialCases_TestC2Ev:
        1:   38:TEST_F(AdditionalCoverageTest, WelfordSpecialCases) {
------------------
_ZN47AdditionalCoverageTest_WelfordSpecialCases_TestD0Ev:
        1:   38:TEST_F(AdditionalCoverageTest, WelfordSpecialCases) {
------------------
_ZN47AdditionalCoverageTest_WelfordSpecialCases_TestD2Ev:
        1:   38:TEST_F(AdditionalCoverageTest, WelfordSpecialCases) {
------------------
_ZN47AdditionalCoverageTest_WelfordSpecialCases_Test8TestBodyEv:
        1:   38:TEST_F(AdditionalCoverageTest, WelfordSpecialCases) {
        1:   39:    welford_accumulator<kbn_sum<double>> acc;
        -:   40:    
        -:   41:    // Test with infinity values (if supported)
        1:   42:    acc += std::numeric_limits<double>::max();
        1:   43:    acc += std::numeric_limits<double>::max();
        -:   44:    
       1*:   45:    EXPECT_TRUE(std::isfinite(acc.mean()) || std::isinf(acc.mean()));
       1*:   46:    EXPECT_EQ(acc.size(), 2u);
        -:   47:    
        -:   48:    // Test move semantics path explicitly
        1:   49:    welford_accumulator<kbn_sum<double>> acc2;
        1:   50:    double temp = 5.0;
        1:   51:    acc2 += std::move(temp); // This triggers the move in delta2 calculation
       1*:   52:    EXPECT_EQ(acc2.mean(), 5.0);
        1:   53:}
------------------
        -:   54:
        -:   55:// Test expression evaluation (if any expression functionality exists)
        4:   56:TEST_F(AdditionalCoverageTest, ExpressionCoverage) {
        -:   57:    // Test if accumulator_exp is used anywhere
        -:   58:    // This might reveal untested template instantiations
        1:   59:    kbn_sum<double> sum1(10.0);
        1:   60:    kbn_sum<double> sum2(20.0);
        -:   61:    
        1:   62:    auto result = sum1 + sum2;
       1*:   63:    EXPECT_EQ(static_cast<double>(result), 30.0);
        1:   64:}
------------------
_ZN46AdditionalCoverageTest_ExpressionCoverage_TestC2Ev:
        1:   56:TEST_F(AdditionalCoverageTest, ExpressionCoverage) {
------------------
_ZN46AdditionalCoverageTest_ExpressionCoverage_TestD0Ev:
        1:   56:TEST_F(AdditionalCoverageTest, ExpressionCoverage) {
------------------
_ZN46AdditionalCoverageTest_ExpressionCoverage_TestD2Ev:
        1:   56:TEST_F(AdditionalCoverageTest, ExpressionCoverage) {
------------------
_ZN46AdditionalCoverageTest_ExpressionCoverage_Test8TestBodyEv:
        1:   56:TEST_F(AdditionalCoverageTest, ExpressionCoverage) {
        -:   57:    // Test if accumulator_exp is used anywhere
        -:   58:    // This might reveal untested template instantiations
        1:   59:    kbn_sum<double> sum1(10.0);
        1:   60:    kbn_sum<double> sum2(20.0);
        -:   61:    
        1:   62:    auto result = sum1 + sum2;
       1*:   63:    EXPECT_EQ(static_cast<double>(result), 30.0);
        1:   64:}
------------------
        -:   65:
        -:   66:// Test all comparison operators thoroughly  
        4:   67:TEST_F(AdditionalCoverageTest, ComparisonOperatorCoverage) {
        1:   68:    kbn_sum<double> sum1(5.0);
        1:   69:    kbn_sum<double> sum2(5.0);
        1:   70:    kbn_sum<double> sum3(3.0);
        -:   71:    
        -:   72:    // Test equality edge cases
        1:   73:    sum1.c = 1e-15; // Add tiny correction
        1:   74:    sum2.c = 1e-15; // Same tiny correction
       1*:   75:    EXPECT_TRUE(sum1 == sum2); // Should still be equal due to conversion
        -:   76:    
        -:   77:    // Test less than with very close values
        1:   78:    sum1.c = 0.0;
        1:   79:    sum2.c = 1e-16;
        1:   80:    bool less_result = sum1 < sum2;
       1*:   81:    EXPECT_TRUE(less_result || !less_result); // Just verify it doesn't crash
        1:   82:}
------------------
_ZN54AdditionalCoverageTest_ComparisonOperatorCoverage_TestC2Ev:
        1:   67:TEST_F(AdditionalCoverageTest, ComparisonOperatorCoverage) {
------------------
_ZN54AdditionalCoverageTest_ComparisonOperatorCoverage_TestD0Ev:
        1:   67:TEST_F(AdditionalCoverageTest, ComparisonOperatorCoverage) {
------------------
_ZN54AdditionalCoverageTest_ComparisonOperatorCoverage_TestD2Ev:
        1:   67:TEST_F(AdditionalCoverageTest, ComparisonOperatorCoverage) {
------------------
_ZN54AdditionalCoverageTest_ComparisonOperatorCoverage_Test8TestBodyEv:
        1:   67:TEST_F(AdditionalCoverageTest, ComparisonOperatorCoverage) {
        1:   68:    kbn_sum<double> sum1(5.0);
        1:   69:    kbn_sum<double> sum2(5.0);
        1:   70:    kbn_sum<double> sum3(3.0);
        -:   71:    
        -:   72:    // Test equality edge cases
        1:   73:    sum1.c = 1e-15; // Add tiny correction
        1:   74:    sum2.c = 1e-15; // Same tiny correction
       1*:   75:    EXPECT_TRUE(sum1 == sum2); // Should still be equal due to conversion
        -:   76:    
        -:   77:    // Test less than with very close values
        1:   78:    sum1.c = 0.0;
        1:   79:    sum2.c = 1e-16;
        1:   80:    bool less_result = sum1 < sum2;
       1*:   81:    EXPECT_TRUE(less_result || !less_result); // Just verify it doesn't crash
        1:   82:}
------------------
